<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mini Platformer - 30 Levels</title>
<style>
  * { margin:0; padding:0; box-sizing: border-box; }
  body, html {
    height: 100%;
    background: linear-gradient(to top, #66ccff 0%, #99ddff 80%, #ffffff 100%);
    display: flex; justify-content: center; align-items: flex-end;
    font-family: 'Courier New', Courier, monospace;
    user-select:none;
  }
  #game {
    position: relative;
    width: 480px;
    height: 320px;
    background: #3cb371;
    overflow: hidden;
    border: 4px solid #2e8b57;
    border-radius: 12px;
    box-shadow: 0 0 20px #2e8b57aa;
  }
  canvas {
    display: block;
    background: linear-gradient(to top, #4d94ff 0%, #99ccff 100%);
    border-radius: 8px 8px 0 0;
  }
  #score {
    position: absolute;
    top: 6px; left: 12px;
    font-size: 18px;
    color: #fff;
    text-shadow: 1px 1px 3px #0008;
  }
  #level {
    position: absolute;
    top: 6px; right: 12px;
    font-size: 18px;
    color: #fff;
    text-shadow: 1px 1px 3px #0008;
  }
  #message {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px;
    color: #fff;
    text-shadow: 2px 2px 8px #0008;
    pointer-events:none;
    user-select:none;
    text-align:center;
    white-space: pre-line;
  }
</style>
</head>
<body>
  <div id="game" tabindex="0" aria-label="Mini Platformer Game">
    <div id="score">Score: 0</div>
    <div id="level">Level: 1</div>
    <canvas id="canvas" width="480" height="320" aria-live="polite" aria-atomic="true"></canvas>
    <div id="message" style="display:none;"></div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const messageEl = document.getElementById('message');
  const gameDiv = document.getElementById('game');

  const GRAVITY = 0.5;
  const FRICTION = 0.8;
  const JUMP_POWER = 11;
  const BASE_PLAYER_SPEED = 4;

  let keys = {};
  let score = 0;
  let gameOver = false;
  let gameWin = false;

  const player = {
    x: 40,
    y: 0,
    width: 28,
    height: 40,
    velX: 0,
    velY: 0,
    jumping: false,
    grounded: false,
    color: '#ff4444',
  };

  // Procedurally generate 30 levels
  function generateLevels(numLevels){
    const levels = [];
    for(let i=0; i<numLevels; i++){
      const levelNum = i + 1;
      const platforms = [];
      const enemies = [];

      // Base platform (ground)
      platforms.push({x:0, y:280, width:480, height:40});

      // Add 3-5 platforms per level, spaced by increasing difficulty
      const platCount = 3 + Math.floor(levelNum / 6);
      for(let p=0; p<platCount; p++){
        // X spreads across canvas width minus some margin
        const width = 80 + Math.random() * 40;
        const x = Math.min(420, 50 + p * 110 + Math.random() * 40);
        // Platforms higher as level increases but vary a bit randomly
        const y = 280 - (p+1)*40 - (levelNum * 3) + Math.random()*20;
        platforms.push({x, y, width, height: 15});
      }

      // Add enemies: 1 + floor(levelNum / 10), faster with levels
      const enemyCount = 1 + Math.floor(levelNum / 10);
      for(let e=0; e<enemyCount; e++){
        const enemyWidth = 25 + (levelNum > 20 ? 10 : 0);
        const enemyHeight = 25;
        const plat = platforms[(e % (platCount)) + 1]; // enemy on one of the platforms (skip ground)
        const speed = 1.5 + levelNum * 0.1 + Math.random() * 0.5;
        const x = plat.x + Math.random() * (plat.width - enemyWidth);
        const y = plat.y - enemyHeight;
        const range = [plat.x, plat.x + plat.width - enemyWidth];
        enemies.push({x, y, width: enemyWidth, height: enemyHeight, speed, dir: 1, range});
      }

      // Star on last platform or near goal
      const starPlat = platforms[platforms.length - 1];
      const star = {
        x: starPlat.x + starPlat.width / 2 - 10,
        y: starPlat.y - 20,
        size: 20,
        collected: false,
      };

      // Goal flag near right edge on ground or last platform with some offset
      const goalPlatform = platforms[platforms.length - 1];
      const goal = {
        x: Math.min(440, goalPlatform.x + goalPlatform.width - 30),
        y: goalPlatform.y - 40,
        width: 30,
        height: 40,
      };

      levels.push({platforms, enemies, star, goal});
    }
    return levels;
  }

  const levels = generateLevels(30);
  let currentLevelIndex = 0;

  window.addEventListener('keydown', e => {
    gameDiv.focus(); // ensure focus to get keys
    if((e.code === 'KeyR' || e.code === 'Enter') && (gameOver || gameWin)){
      resetGame();
      return;
    }
    keys[e.code] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.code] = false;
  });

  function rectsColliding(r1, r2) {
    return !(r2.x > r1.x + r1.width ||
             r2.x + r2.width < r1.x ||
             r2.y > r1.y + r1.height ||
             r2.y + r2.height < r1.y);
  }

  function circleRectColliding(circle, rect) {
    let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
    let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
    let dx = circle.x - closestX;
    let dy = circle.y - closestY;
    return (dx*dx + dy*dy) < (circle.size/2)*(circle.size/2);
  }

  function update() {
    if(gameOver || gameWin) return;

    const level = levels[currentLevelIndex];
    const PLAYER_SPEED = BASE_PLAYER_SPEED + currentLevelIndex * 0.05; // Slight speed up per level

    if((keys['ArrowRight'] || keys['KeyD']) && player.velX < PLAYER_SPEED) {
      player.velX += 0.5;
    }
    if((keys['ArrowLeft'] || keys['KeyA']) && player.velX > -PLAYER_SPEED) {
      player.velX -= 0.5;
    }

    if((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && !player.jumping && player.grounded) {
      player.jumping = true;
      player.grounded = false;
      player.velY = -JUMP_POWER;
    }

    player.velX *= FRICTION;
    player.velY += GRAVITY;

    player.x += player.velX;
    player.y += player.velY;

    if(player.x < 0) {
      player.x = 0;
      player.velX = 0;
    }
    if(player.x + player.width > canvas.width) {
      player.x = canvas.width - player.width;
      player.velX = 0;
    }

    player.grounded = false;
    for(let plat of level.platforms) {
      if(
        player.x < plat.x + plat.width &&
        player.x + player.width > plat.x &&
        player.y < plat.y + plat.height &&
        player.y + player.height > plat.y
      ) {
        if(player.velY > 0 && (player.y + player.height - player.velY) <= plat.y) {
          player.grounded = true;
          player.jumping = false;
          player.y = plat.y - player.height;
          player.velY = 0;
        }
      }
    }

    // Enemy movement & collision
    for(let enemy of level.enemies){
      enemy.x += enemy.speed * enemy.dir;
      if(enemy.x < enemy.range[0]) enemy.dir = 1;
      else if(enemy.x + enemy.width > enemy.range[1]) enemy.dir = -1;

      if(rectsColliding(player, enemy)){
        gameOver = true;
        messageEl.textContent = 'Game Over! You touched an enemy.\nPress R or Enter to Restart';
        messageEl.style.display = 'block';
      }
    }

    // Collect star
    const star = level.star;
    if(!star.collected && circleRectColliding(
      {x: star.x + star.size/2, y: star.y + star.size/2, size: star.size},
      {x: player.x, y: player.y, width: player.width, height: player.height}
    )) {
      star.collected = true;
      score++;
      scoreEl.textContent = 'Score: ' + score;
    }

    // Check goal collision (only if star collected)
    const goal = level.goal;
    if(star.collected && rectsColliding(player, goal)){
      currentLevelIndex++;
      if(currentLevelIndex >= levels.length){
        gameWin = true;
        messageEl.textContent = `You WIN! Final Score: ${score}\nPress R or Enter to Restart`;
        messageEl.style.display = 'block';
      } else {
        loadLevel(currentLevelIndex);
      }
    }

    if(player.y > canvas.height + 20){
      gameOver = true;
      messageEl.textContent = 'Game Over! You fell.\nPress R or Enter to Restart';
      messageEl.style.display = 'block';
    }
  }

  function loadLevel(index){
    const level = levels[index];
    player.x = 40;
    player.y = 0;
    player.velX = 0;
    player.velY = 0;
    player.jumping = false;
    player.grounded = false;
    level.star.collected = false;
    messageEl.style.display = 'none';
    levelEl.textContent = `Level: ${index + 1}`;
  }

  function resetGame(){
    score = 0;
    currentLevelIndex = 0;
    gameOver = false;
    gameWin = false;
    messageEl.style.display = 'none';
    scoreEl.textContent = 'Score: 0';
    loadLevel(0);
  }

  function drawStar(cx, cy, spikes, outerRadius, innerRadius, fillStyle, strokeStyle) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    for(let i = 0; i < spikes; i++){
      x = cx + Math.cos(rot) * outerRadius;
      y = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;

      x = cx + Math.cos(rot) * innerRadius;
      y = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fillStyle = fillStyle;
    ctx.fill();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    skyGradient.addColorStop(0, '#4d94ff');
    skyGradient.addColorStop(1, '#99ccff');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const level = levels[currentLevelIndex];

    ctx.fillStyle = '#2e8b57';
    for(let plat of level.platforms){
      ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
      ctx.strokeStyle = '#245b3a';
      ctx.lineWidth = 3;
      ctx.strokeRect(plat.x, plat.y, plat.width, plat.height);
    }

    // Draw enemies
    ctx.fillStyle = '#aa0000';
    for(let enemy of level.enemies){
      ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
      // enemy eyes
      ctx.fillStyle = '#000';
      ctx.fillRect(enemy.x+6, enemy.y+8, 6, 6);
      ctx.fillRect(enemy.x+16, enemy.y+8, 6, 6);
      ctx.fillStyle = '#aa0000';
    }

    // Draw player
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // player eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(player.x + 7, player.y + 12, 5, 0, Math.PI * 2);
    ctx.arc(player.x + 21, player.y + 12, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(player.x + 8, player.y + 13, 2, 0, Math.PI * 2);
    ctx.arc(player.x + 22, player.y + 13, 2, 0, Math.PI * 2);
    ctx.fill();

    // Draw star if not collected
    const star = level.star;
    if(!star.collected) {
      drawStar(star.x + star.size/2, star.y + star.size/2, 5, star.size/2, star.size/4, '#ffdd00', '#bb9900');
    }

    // Draw goal flag
    const goal = level.goal;
    // flag pole
    ctx.strokeStyle = '#552200';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(goal.x + 8, goal.y + goal.height);
    ctx.lineTo(goal.x + 8, goal.y);
    ctx.stroke();
    // flag cloth
    ctx.fillStyle = '#00aa00';
    ctx.beginPath();
    ctx.moveTo(goal.x + 8, goal.y);
    ctx.lineTo(goal.x + 28, goal.y + 10);
    ctx.lineTo(goal.x + 8, goal.y + 20);
    ctx.closePath();
    ctx.fill();
  }

  function gameLoop() {
    update();
    render();
    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    score = 0;
    currentLevelIndex = 0;
    gameOver = false;
    gameWin = false;
    messageEl.style.display = 'none';
    scoreEl.textContent = 'Score: 0';
    loadLevel(0);
    gameDiv.focus();
  }

  startGame();
  gameLoop();

})();
</script>
</body>
</html>
